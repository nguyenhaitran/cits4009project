---
title: "CITS4009-Individual Project"
author: "Henry Tran"
date: "2024-10-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Install all the required packages
library(ggplot2)
library(shiny)
library(gridExtra)
library(reshape2)
library(readxl)
library(dplyr)
```

```{r}
# Read the data
path<-url("https://lms.uwa.edu.au/bbcswebdav/pid-3998436-dt-content-rid-47695412_1/courses/CITS4009_SEM-2_2024/Countries%20and%20death%20causes.csv")
```

# Data Exploratory
```{r}
data<-read.csv(path, header=TRUE)
head(data)
nrow(data)
```
The data has 31 columns and 6840 rows. For the column names, they can be seen that the column names have dot-separated between each word.

```{r}
str(data)
```
```{r}
summary(data)
```
For the first 2 columns, "Entity" and "Code" store different country names and codes. Therefore, to set them as a country as a unique value, it would be the best to convert them into factor

```{r}
data$Entity<-as.factor(data$Entity)
data$Code<-as.factor(data$Code)
data$Year<-as.factor(data$Year)

summary(data)
str(data)
```

```{r}
unique(data$Entity)
```


There are 228 unique entities but there are only 206 codes in this dataset. The reason is because there are some countries and regions do not have unique codes.

There are also no missing data

```{r}
total_missing_value = sum(is.na(data))
total_missing_value
```

While with remaining 29 columns, the maximum numbers are extremely larger than other values. The reason is because the dataset did not only record deaths of countries, but it also recorded the total deaths in groups, regions and in the world. Therefore, if we do the data analysis on the whole dataset, it will create skewness problem. The solution for this would be we can seperated data into different groups: countries, regions and world. I have some examples of the single eda below:

```{r}
boxplot(data$High.systolic.blood.pressure)
```
```{r}
eg1<-log1p(data$Outdoor.air.pollution)
boxplot(eg1)
```



For data exploratory, it will be done using Shiny app

```{r}
# Define UI for application that draws different plot
ui <- fluidPage(
    titlePanel("Visualisation of death in country/region during 1990 - 2019"),
    selectInput("plot_type", "Select plot type:", choices = c("Line plot", "Boxplot", "Heat map", "Correlation plot")),
    sidebarLayout(
        sidebarPanel(
            conditionalPanel(
              condition = "input.plot_type == 'Line plot'",
              checkboxInput("compare", "Compare between 2 countries/regions", FALSE),
            ),
            selectInput("region1", "Choose the first country/region:", choices = unique(data$Entity)),
            conditionalPanel(
              condition = "input.compare == true",
              selectInput("region2", "Choose the second country/region:", choices = unique(data$Entity))
            ),
            conditionalPanel(
              condition = "input.plot_type == 'Line plot'",
              selectInput("reason", "Choose death reason:", choices = names(data)[4:31])
            ),
        ),
        mainPanel(            
          plotOutput("plot1", width = "100%", height = "600px"),
            conditionalPanel(
                condition = "input.compare == true && input.plot_type == 'Line plot'",  # Display plot2 only if compare is checked
                plotOutput("plot2", width = "100%", height = "600px"))
        )
    )
)


# Define the server
server <- function(input, output){
    # Render the histograms
    output$plot1 <- renderPlot({
      region_data<-data[data$Entity==input$region1,]
      # Plot selected death reason
      if (input$plot_type == 'Line plot'){
      ggplot(region_data, aes_string(x="Year", y=input$reason, group = "Entity")) +
          geom_line(color="darkorange") + 
          labs(x="Year", y = input$reason) +
          theme(axis.text.x = element_text(angle = 45, hjust = 1))}
      # Plot the boxplot
      else if (input$plot_type == 'Boxplot'){
        data_melt <- melt(region_data, id.vars = "Year", measure.vars = names(data)[4:31], 
                          variable.name = "death_reason", value.name = "value")
        ggplot(data_melt, aes(x = death_reason, y = value, fill = death_reason)) +
          geom_boxplot() +
          labs(x = "Death Reason", y = "Number of Deaths", title = paste("Boxplot of Death Reasons in", input$region1)) +
          theme_minimal() +
          theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "top")+
          guides(fill = guide_legend(ncol = 3))
        }
      
      # Plot the Heat Map for selected country
      else if (input$plot_type == 'Heat map'){
        data_melt <- melt(region_data, id.vars = "Year", measure.vars = names(data)[4:31], variable.name = "death_reason", value.name = "value")
        # Create heat map
        ggplot(data_melt, aes(x = Year, y = death_reason, fill = value)) + 
            geom_tile() + 
            scale_fill_gradient(low = "aliceblue", high = "blue") +
            scale_x_discrete(breaks = levels(region_data$Year)) +
            labs(x = "Year", y = "Death Reason", title = paste("Heat Map of Death Reasons in", input$region1)) +
            theme_minimal() +
            theme(axis.text.x = element_text(angle = 45, hjust = 1))
      }
      else if (input$plot_type == "Correlation plot"){
        # Extract the number of death for each death reasons
        numeric_data <- region_data[,4:31]
         
        # Calculate the correlation for all variables
        correlation <- cor(numeric_data)
        
        # Melt the correlation for visualization
        correlation_melted <- melt(correlation)
        
        # Create the correlation heatmap
        ggplot(correlation_melted, aes(x = Var1, y = Var2, fill = value)) +
          geom_tile() +
          scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, limit = c(-1, 1), name = "Correlation") +
          theme_minimal() +
          theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
          labs(title = "Correlation Plot of Death Reasons", x = "Variables", y = "Variables")
      }
    })
    output$plot2 <- renderPlot({ 
      if (input$compare == TRUE && input$plot_type == 'Line plot'){
      region_data<-data[data$Entity==input$region2,]
      # Plot all death reasons
      ggplot(region_data, aes_string(x="Year", y=input$reason, group ="Entity")) + geom_line(color="darkolivegreen") + labs(x="Year", y = input$reason)
    }
  })
}

# Run the Shiny app
shinyApp(ui = ui, server = server)
```
The data needs to be transformed, including divided the data into different groups, including countries, regions. Additionally, log-transformation will be applied for data transformation

## Data Transformation

Firstly, the data will be divided into 2 groups: country and region

There are 28 countries and regions in this data. There are few information we can know if the Entity is a region, including:
- Ends with (WB) or (WHO)
- Start with "World"
- G20
And anything other than this will be considered to be countries.
Here is how we will divide the data into groups

```{r}
region_mask <- grepl("(WB)|(WHO)|^World|^G20|^OECD", data$Entity)

regions<-data[region_mask,]
countries<-data[!region_mask,]
```

```{r}
countries
```

```{r}
regions
```

```{r}
```


#Model: Binary classification low income countries based on death causes
For the classification model, the model will classify the Sub-Saharan African countries based on the death causes. The reason to build this model is because the Sub-Saharan African countries could have different death causes compared to countries from other regions.

According to World Bank, there are 48 countries in the low-income groups. Therefore, we will have a column to label them, the country in Sub-Saharan African region will be 1 and 0 for countries from other regions. 

There is a data file of countries in regions from World Bank. This file will be merge with the current data that we are processing

```{r}
#Here is my file path, please change to your filepath to where you downloaded the file
path<-"/Users/henrytran/Documents/UWA_Master-Data-Science/CITS4009/Project/"
```

```{r}
country_groups_file<- paste0(path, "World Bank Country Groups.xlsx")
country_groups_df<-read_excel(country_groups_file, sheet = "List of economies")
head(country_groups_df)
```
The data that we need will include the the Economy, Code and Income group. Therefore, we will keep only 3 columns

```{r}
country_groups_df<-country_groups_df[,c(1,2,3)] #We need the first 3 columns - Economy, Code, Region
country_groups_df
```
Now, we will merge countries dataset with country groups dataset using Code as key, and we keep all the data on the countries dataset
```{r}
countries_merged<-merge(countries, country_groups_df, by.x="Code", by.y="Code", all.x=TRUE)
countries_merged
```
As there are 4 countries do not have Code, including Northen Ireland, Wales, Scotland, and England. They are all in United Kingdom (UK). Now we will double check to see if the total death of UK is the same to the total death of 4 countries
```{r}
countries_merged[countries_merged$Entity=="United Kingdom",]
```


```{r}
total_uk_death <- colSums(countries_merged[countries_merged$Entity=="United Kingdom", 4:31], na.rm = TRUE)
total_uk_death
```

```{r}
four_countries_death <- subset(countries_merged, Entity %in% c("England", "Northern Ireland", "Wales", "Scotland"))
four_countries_death
```
```{r}
total_four_countries_death <- colSums(four_countries_death[, 4:31], na.rm = TRUE)
total_four_countries_death
```
After calculating the total deaths of 4 countries over years, the numbers of death recorded for each reasons are almost the same to the total deaths of UK over years. Therefore, we will drop these 4 countries out of the countries merged dataset.

Now we will calculate the total death of each country for all death causes.
```{r}
countries_merged<-merge(countries, country_groups_df, by.x="Code", by.y="Code")
countries_merged<-countries_merged[,-32]
countries_merged
```
```{r}
# For the data, group the data into entity and region, then calculate the total death of each death causes of each country
total_deaths_by_country <- countries_merged %>% group_by(Entity, Region) %>% summarise(across(c("Outdoor.air.pollution": "Iron.deficiency"), sum))

# View the result
print(total_deaths_by_country)

```







